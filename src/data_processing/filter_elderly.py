#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Filter elderly-related mental health counseling records from a CSV dataset.
Designed for datasets with columns: ["title", "content", "score"] but will adapt if columns differ.

Usage (CLI):
    python filter_elderly.py --input Data/dataset.csv --output Data/processed_data/elderly_subset.csv --min-score 0

Heuristics:
- Keyword match (Chinese + English)
- Kinship terms (grandma, grandfather, 奶奶, 爷爷, etc.)
- Age patterns: "my mom (72)", "age 67", "65-year-old", "我父亲，78岁"
- Care context: "nursing home", "retirement home", "老人院", "看护", etc.

Author: (generated by ChatGPT)
"""

from __future__ import annotations
import argparse
import os
import re
import sys
from typing import Iterable, List, Dict, Any

import pandas as pd


# -------------------- Keyword Dictionaries --------------------

EN_ELDERLY_KEYWORDS: List[str] = [
    # core
    "elderly", "senior citizen", "senior citizens", "senior", "seniors", "aging parent", "aging parents",
    "older adult", "older adults", "aged care", "geriatric",
    # kinship
    "grandma", "grandmother", "granny", "nana", "grandpa", "grandfather", "granddad", "grandad",
    "grandparent", "grandparents",
    # parents (when context + age pattern will reinforce)
    "my mother", "my father", "mom", "mum", "dad", "parents",
    # care context
    "nursing home", "retirement home", "care home", "assisted living", "long-term care", "hospice",
    "dementia", "alzheimer", "alzheimers", "alzheimers'", "alzheimers’s", "parkinson",
    "fall risk", "frail", "wheelchair", "walker"
]

CN_ELDERLY_KEYWORDS: List[str] = [
    "老人", "老年人", "长者", "高龄", "独居老人", "空巢老人", "老伴", "老人院", "养老院", "护理院",
    "看护", "照护", "赡养", "失智", "阿尔茨海默", "帕金森", "老年抑郁", "跌倒风险",
    # 亲属
    "爷爷", "奶奶", "外公", "外婆", "姥爷", "姥姥", "祖父", "祖母", "外祖父", "外祖母",
    "父亲", "母亲", "爸爸", "妈妈", "双亲", "家中老人"
]

# Compile a single regex for speed (word boundaries for EN; loose match for CN)
EN_PATTERN = re.compile(r"\b(" + r"|".join([re.escape(k) for k in EN_ELDERLY_KEYWORDS]) + r")\b", re.IGNORECASE)
CN_PATTERN = re.compile("|".join([re.escape(k) for k in CN_ELDERLY_KEYWORDS]))

# Age patterns: English and Chinese
AGE_PATTERNS = [
    # English: 65-year-old, 70 year old, age 75, (72), turned 80
    re.compile(r"\b([6-9]\d)\s*-\s*year\s*-\s*old\b", re.IGNORECASE),
    re.compile(r"\b([6-9]\d)\s*(?:year|yrs|yo|y/o)[- ]?old\b", re.IGNORECASE),
    re.compile(r"\b(age|aged)\s*([6-9]\d)\b", re.IGNORECASE),
    re.compile(r"\(\s*([6-9]\d)\s*\)", re.IGNORECASE),  # parentheses with an age
    # Chinese: 65岁、70 岁、已 80 岁
    re.compile(r"([6-9]\d)\s*岁"),
]

# Helper: safe lower
def norm_text(x: Any) -> str:
    if pd.isna(x):
        return ""
    # Keep original for CN regex, but also create a lowercase version for EN matching
    if isinstance(x, str):
        return x
    return str(x)

def any_age_match(text: str) -> bool:
    for p in AGE_PATTERNS:
        if p.search(text):
            # ensure the age is >= 60
            m = p.search(text)
            if m:
                # find the first capturing group that is a number
                for g in m.groups():
                    if g and str(g).isdigit():
                        if int(g) >= 60:
                            return True
                # if groups not purely numeric (like "age"), still treat as match (already constrained)
                return True
    return False

def is_elderly_related(text: str) -> bool:
    if not text:
        return False
    # Chinese match
    if CN_PATTERN.search(text):
        return True
    # English match (lowercased for word boundaries)
    if EN_PATTERN.search(text.lower()):
        return True
    # Age heuristic
    if any_age_match(text):
        return True
    return False


def build_argparser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="Filter elderly-related counseling records from CSV.")
    p.add_argument("--input", "-i",  default="../../Data/Depression_Dataset/dataset_clean.csv",
                   help="Path to input CSV file (e.g., Data/Depression_Dataset/dataset.csv)")
    p.add_argument("--output", "-o", default=None,help="Path to output CSV file")
    p.add_argument("--min-score", type=float, default=None, help="Optional: keep rows with score >= MIN_SCORE")
    p.add_argument("--title-col", default="title", help='Title column name (default: "title")')
    p.add_argument("--content-col", default="content", help='Content column name (default: "content")')
    p.add_argument("--score-col", default="score", help='Score column name (default: "score")')
    p.add_argument("--keep-cols", nargs="*", default=None, help="Optional: subset of columns to keep in output")
    return p


def main(args: argparse.Namespace) -> int:
    in_path = args.input
    if args.output is None:
        in_dir = os.path.dirname(os.path.abspath(in_path))
        out_path = os.path.join(in_dir, "elderly_subset.csv")
    else:
        out_path = args.output
    os.makedirs(os.path.dirname(out_path), exist_ok=True)

    # Load
    try:
        df = pd.read_csv(in_path)
    except UnicodeDecodeError:
        df = pd.read_csv(in_path, encoding="utf-8", errors="ignore")
    except Exception as e:
        print(f"[Error] Failed to read CSV: {e}", file=sys.stderr)
        return 2

    # Verify columns
    cols = df.columns.tolist()
    for need in [args.title_col, args.content_col]:
        if need not in cols:
            print(f"[Error] Column '{need}' not found. Available columns: {cols}", file=sys.stderr)
            return 2

    # Optional score filter
    if args.min_score is not None and args.score_col in cols:
        df = df[df[args.score_col].fillna(-1) >= args.min_score]

    # Text to scan = title + content
    titles = df[args.title_col].map(norm_text)
    contents = df[args.content_col].map(norm_text)
    texts = titles.fillna("") + " " + contents.fillna("")

    mask = texts.map(is_elderly_related)
    out_df = df[mask].copy()

    # Optional column subset
    if args.keep_cols:
        keep = [c for c in args.keep_cols if c in out_df.columns]
        if keep:
            out_df = out_df[keep]

    # Save
    out_df.to_csv(out_path, index=False)
    # Report
    print(f"[OK] Input rows: {len(df)} | Matched elderly-related: {len(out_df)}")
    rate = 0 if len(df) == 0 else len(out_df) / len(df)
    print(f"[INFO] Match rate: {rate:.2%}")
    print(f"[INFO] Saved to: {out_path}")
    return 0


if __name__ == "__main__":
    parser = build_argparser()
    sys.exit(main(parser.parse_args()))
